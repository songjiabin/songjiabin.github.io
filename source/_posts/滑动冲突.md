---
title: 滑动冲突
date: 
tags: 
- android 
- 自定义view
- 源码分析
copyright: true
categories: android
---


<blockquote class="blockquote-center">人若有志，万事可为</blockquote>

<!-- more -->


从源码分析
Activity中的dispatchTouchEvent（）方法
```Java
Class Activity 
 public boolean dispatchTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            onUserInteraction();
        }
        //将事件分发给 window  
        // 如果 window 返回的True 则表示事件终止了，否则事件交给Activity的onTouchEvent（）处理
        if (getWindow().superDispatchTouchEvent(ev)) {
            return true; //事件被消费了 事件终止传递
        }
        return onTouchEvent(ev);// /没有View可以处理，调用Activity onTouchEvent方法
    }

```



Window中的dispatchTouchEvent（）方法

```Java
class PhoneWindow
    // This is the top-level view of the window, containing the window decor.
    private DecorView mDecor;
    public boolean superDispatchTouchEvent(MotionEvent event) {
        return mDecor.superDispatchTouchEvent(event);
    }
```

继续找mDecor的superDispatchTouchEvent（）方法 在ViewGroup 


```Java
public boolean dispatchTouchEvent(MotionEvent ev) {
        ...
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // 当事件是 ACTION_DOWN 
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            //清除FLAG_DISALLOW_INTERCEPT设置并且mFirstTouchTarget 设置为null
            
            resetTouchState();
        }

 // Check for interception.
        final boolean intercepted;//是否拦截事件
        //当 事件是 ACTION_DOWN 或者是 mFirstTouchTarget！=null(意思就是：即事件由子View处理)
        if (actionMasked == MotionEvent.ACTION_DOWN
                || mFirstTouchTarget != null) {
            //FLAG_DISALLOW_INTERCEPT是子View通过
            //requestDisallowInterceptTouchEvent方法进行设置的
            //子View可以通过requestDisallowInterceptTouchEvent方法干预父View的事件分发过程（ACTION_DOWN事件除外
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                //调用onInterceptTouchEvent方法判断是否需要拦截
                intercepted = onInterceptTouchEvent(ev);
                ev.setAction(action); // restore action in case it was changed
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        ...
    }

 

```

**子View可以通过requestDisallowInterceptTouchEvent方法干预父View的事件分发过程（ACTION_DOWN事件除外）**

为什么ACTION_DOWN除外？通过上述代码我们不难发现。如果事件是ACTION_DOWN，那么ViewGroup会重置FLAG_DISALLOW_INTERCEPT标志位并且将mFirstTouchTarget 设置为null。对于mFirstTouchTarget 我们可以先这么理解，如果事件由子View去处理时mFirstTouchTarget 会被赋值并指向子View。

 
所以当事件为ACTION_DOWN 或者 mFirstTouchTarget ！=null（即事件由子View处理）时会进行拦截判断。具体规则是如果子View设置了FLAG_DISALLOW_INTERCEPT标志位，那么intercepted =false。否则调用onInterceptTouchEvent方法。
 



如果事件不为ACTION_DOWN 且事件为ViewGroup本身处理（即mFirstTouchTarget ==null）那么intercepted =false，很显然事件已经交给自己处理根本没必要再调用onInterceptTouchEvent去判断是否拦截。


结论

> **当ViewGroup决定拦截事件后，后续事件将默认交给它处理并且不会再调用onInterceptTouchEvent方法来判断是否拦截。子View可以通过设置FLAG_DISALLOW_INTERCEPT标志位来不让ViewGroup拦截除ACTION_DOWN以外的事件。**


> **所以我们知道了onInterceptTouchEvent并非每次都会被调用。如果要处理所有的点击事件那么需要选择dispatchTouchEvent方法
而FLAG_DISALLOW_INTERCEPT标志位可以帮助我们去有效的处理滑动冲突**




